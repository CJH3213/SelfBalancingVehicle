向OLED通过I2C发送数据，数据传输顺序如下：

1字节		|	1字节		|	1或多个字节
从设备地址	|	寄存器地址	|	一个或多个数据...

每一条发送只能指定一个寄存器地址，也就是紧跟着从设备地址
发送后的下一个字节，寄存器地址发送完毕，之后的字节全部都是
写入该寄存器内。

0x00寄存器地址称为“写数据”指令，向它写入一个字节，屏幕
上就会显示8个竖点。每次向该寄存器写入一个字节后，列坐标计数器
就会自动加1，当列坐标等于128时归零。

结合以上，在绘图、刷屏等需大量“写数据”时，是可以一次将多个数据
一起发送出去的，减少了重复发送设备地址和寄存器地址的时间浪费。

从设备地址	|	寄存器地址	|	1列		|	2列		|	3列		|	...




假设要把20个字节的数据发送到OLED显示，下面对比新老程序写法：

老代码：
uint8_t bytes[20];
for(uint8_t x=0; x<20; ++x)
	HAL_I2C_Mem_Write(&hi2c2, DevAddr(设备地址), 0x00(寄存器地址), I2C_MEMADD_SIZE_8BIT，bytes[x], 1, Timeout);
从设备地址	|	寄存器地址	|	1列	
从设备地址	|	寄存器地址	|	2列	
从设备地址	|	寄存器地址	|	3列	
...
从设备地址	|	寄存器地址	|	20列	


改为新代码：
uint8_t bytes[20];
HAL_I2C_Mem_Write(&hi2c2, DevAddr(设备地址), 0x00(寄存器地址), I2C_MEMADD_SIZE_8BIT，bytes, sizeof(bytes), Timeout);
从设备地址	|	寄存器地址	|	1列		|	2列		|	3列		|	...	|	20列




注意：
1.	只有寄存器地址相同的数据，才能用一次发送多个数据的方式；
	“写数据”和“写命令”要分开发送，甚至不同命令也要分开发送。
2.	向0x00寄存器“写数据”，OLED内部的列地址计数器会自增，但页
	计数器不会自增。
3.	DMA发送并不是简单地将HAL_I2C_Mem_Write()换成HAL_I2C_Mem_Write_DMA()，
	这样写本质上还是阻塞，甚至有人测试出来更慢了。用户层和硬件层要异步、分离，
	才能充分发挥DMA的优势，我大概构思了一下怎么实现：

	先定义一个缓存发送数据的 uint8_t txBuffer[n][2];
	txBuffer[i][0]存寄存器地址，buffer[i][1]存数据

	将原代码中发送数据命令的地方不要通过HAL_I2C_Mem_Write()直接发出去，
	而是将这一条发送的寄存器地址和数据分别存入txBuffer[i][0]和txBuffer[i][1]，
	
	用户侧将需要发送的数据存放完毕后，接下来需要将连续的寄存器地址相同的数据一起发送出去。
	从txBuffer[0][0]开始，向下判断下面的发送寄存器地址是否相同，
	直到找到与txBuffer[0][0]不同的寄存器地址，将前面相同寄存器
	地址的数据打个包一起发送出去，
	之后主循环就与IO操作无关了，发送过程并没有阻塞主循环。

	很快第一批数据发送完成，触发发完中断，在中断里面重复上面的判断过程，
	再次将连续的寄存器地址相同的数据一起发送出去，
	直到txBuffer里储存的数据全部被发送完毕，一帧就刷新完毕。

	这样用户层只会向txBuffer打交道，没有涉及等待IO操作，用户层可顺畅无比地执行，
	而IO操作由DMA自动从txBuffer取值发送，也不需要cpu处理，
	只有在每次DMA发送完成的中断里处理一下下就行。

	这种方式在进行大量“写数据”、少量“写命令”操作时效率比较高，
	如果txBuffer连续相同寄存器地址不多，会频繁触发DMA发送完成中断，效率就不高了，
	所以DMA发送适合全屏帧缓存刷新，而不适合OLED初始化。
